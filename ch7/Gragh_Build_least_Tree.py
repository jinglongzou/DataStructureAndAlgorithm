#通过图构造最小生成树
#最小生成树：
#   将图G的生成树中各边权值之和称为生成树的权
#   图可以生成许多树，而其中权最小的树称为图G的最小生成树。
###############################################################
#需要导入的类
from Gragh_AdjList import GraghAL
#####################################################################
#Kruskal算法
#基本思想：从图的边集中每次选择权最小的边，将边的顶点加入最小生成树。直到所有顶点都在最小树中。
#   选择权最小的边的方法：1、每次扫描选出最短边；2、排序后按顺序选择；3、使用优先队列
#   由于选择一天边后，需要统一顶点的代表元，减少连通分量
#   reps为每个顶点的代表元
#############################################################################################
#这里通过邻接矩阵或者邻接表，首先提取出所有的边，并将他们排序，然后每次选择一条边来处理，指导所有顶点都在最小树中
#   注：这里的图是假定为连通图
##############################
#四步：1、取出所有边
#      2、排序边           #注：这里的1、2步可以通过构建优先队列来实现
#      3、选择最小边
#      4、维护每个节点的代表元
def Krustal(gragh):
    vnum = gragh.vertex_num()
    reps = [ i for i in range(vnum)]
    mst,edges = [],[]
    #从邻接表中提取出所有的边
    for vi in range(vnum):
        for v,w in gragh.out_edges(vi):
            edges.append((w,vi,v))
    #对所有的边排序
    edges.sort()
    #选取边,加入最小生成树   注：这里加入创建的树，最终得到的只是建立树的各节点的关系，
    #                            并没有作为之前学习树的结构形式存储，化为那种形式需要进一步处理
    for w,vi,vj in edges:
        if reps[vi] != reps[vj]:
            mst.append(((vi,vj),w))
            if len(mst) == vnum - 1:
                break
            rep,repo = reps[vi],reps[vj]
            for i in range(vnum):
                if reps[i] == repo:
                    reps[i] = rep
    return mst
#算法复杂度分析
#时间复杂度：
#        提取边并加入列表：对邻接矩阵需要创建边O(V^2)，对邻接表需要访问边O(E),加入列表的是O(1)，因此这一步的时间复杂度
#        为O(V^2) * O(1) 或者O(E) * O(1)
#        边的排序：依据排序的算法的不同，时间复杂度不同，好的能实现O(ElogE)的时间复杂度
#        选边构造最小数：主循环里分为两个分支，一个进入条件体，一个不进入；
#                         进入条件体的次数最多vnum - 1次，没记录一条边后修改代表元的小循环需要O(V)的时间，
#                         因此这部分的时间是O(V^2)。 注：改进这段算法的修改代表元的方式可以降低复杂度
#             故主循环的时间复杂度为max(O(E),O(V^2))
#       总的时间复杂度为max(O(ElogE),O(V^2))
#空间复杂度：
#       算法中用了保存边的表edges,和另外连个表reps,mst(大小均由顶点数确定),因此空间复杂度为max(O(E),O(V))

#注：通过其他技术和辅助结构可以降到O(ElogE)的时间复杂度
#    通过不同的具体辅助数据结构和不同的图实现方法，可能具有不同的时间、空间复杂度


############################################################################################################
#prim算法
#基本思想：将顶点分为两个集合，一个是已知的最小树的顶点U，另一个是图顶点集合V中不包括U的顶点集合V-U.
#          每次选择U中顶点到V-U中顶点的边中权最小的边，并将该边上的V-U中的顶点,从V-U中删除并加入U。
#          这里需要标记顶点是属于哪个集合，可以采用之前遍历采用标记来实现，属于U为1,不属于U为0
#############################################################################################################
#思考： 选择集合U中顶点到集合V-U中顶点的边，并取其中权最小的边，判断这条边的两个顶点是否在同一集合，
#       不是就加入最小树，是就跳过。
#       因此：需要变量：存边的变量，标记集合的变量，存最小树的变量
#程序处理的流程：
#       随机选择一个点开始，把顶点0记入最小生成树顶点集U,方法是设置元素mst[0]=((0,0),0)
#       提取该点的所有边，选择最小权的边,这里采用优先队列来存边，选择边。这样每次U中加入一个顶点，只需添加新加入顶点的邻接边
#       当最小树中加入的边数为vnum(因为初始加入了[(0,0,0)]这个初始边) 或者优先队列为空的时候，就访问建立了最小树或者访问了所有顶点
from PriorityQueue_heaps import PrioQueue
def Prim(gragh):
    vnum = gragh.vertex_num()
    mst = [None] * vnum
    cands = PrioQueue([(0,0,0)])  #记录候选边
    count = 0  #统计加入最小树的边的条数
    while count < vnum or not cands.is_empty():  #当最小树的边的条数为vnum或者优先队列为空的时候
        w,u,v = cands.dequeue()
        if mst[v]:  #判断u的邻接点是否在集合U中
            continue
        mst[v] = ((u,v),w)
        count +=1
        for vi,w in gragh.out_edges(v):
            if not mst[vi]: #判断v的邻接点是否在集合U中，不在的话，就将这条边加入优先队列
                cands.enqueue((w,v,vi))
    return mst
#复杂度分析
#时间复杂度：
#           构造边的复杂度：对邻接矩阵需要创建边O(V^2)，对邻接表需要访问边O(E),加入列表的是O(1)，因此这一步的时间复杂度
#           为O(V^2) * O(1) 或者O(E) * O(1)
#           出入队操作：有E条边，出入队最多E次，同时每次出入队的复杂度为logE，因此出入队的时间复杂度为ElogE.
#           因此总的时间复杂度是：对邻接矩阵为max(O(V^2,ElogE),对邻接表O(ElogE)

#空间复杂度：
#           算法中用了优先队列(大小由边数确定)和表mst(大小由顶点数确定),因此空间复杂度为max(O(E),O(V))
#################################################################################################################
#Prim改进算法
#   前面的prim算法有个缺点就是把没有用的边也存入了队列，是的计算的空间复杂度为O(E)。对不同的实例，加入队列的边
#   的情况差别很大
#   为了实现prim算法，实际只需连接顶点集合U和V-U的边。为完成这一运算，保存|V|条边就够了。同时在降低空间复杂度时，
#   也不能增加时间复杂度。
#   为了保证算法的效率，所用的数据结构必须有效支持下列操作:
#       获取连接中的最短边。可以采用堆结构，时间复杂度为O(logV)
#       向U中加入的新顶点，可能发现到V-U中顶点的更短连接边。为此需要从节点出发，找到阈值对应的堆元素，修改其权值并
#       恢复堆结构
infinity = float('inf')
from DecPrioHeap_For_Prim import DecPrioHeap
def Optimized_Prim(gragh):
    vnum = gragh.vertex_num()
    wv_seq = [[gragh.get_edges(0,v),0,v] for v in range(vnum)]   #初始化起点到所有顶点的权
    connects = DecPrioHeap(wv_seq)  #将初始化的序列构造为减权堆，类似于优先队列，其与有优先队列的主要区别就是修改元素值
                                    #每次弹出一条连接两个集合的最短边
    mst = [None] * vnum
    while not connects.is_empty():
        w,vi,vj = connects.dequeue()
        if w == infinity:
            break
        mst[vj] = ((vi,vj),w)
        for v,w in gragh.out_edges(vj):
            if not mst[v] and w < connects.weight(v):
                connects.dec_weight(w,vj,v)
    return mst
#
#复杂度分析
#时间复杂度：
#           创建wv_seq和创建堆connexts的时间复杂度都是O(V)
#           出队次数最多也为O(V),每次出队的复杂度为O(logV)
#           查询边复杂度为O(E),修改后维护堆的复杂度为O(V),所以for循环的复杂度为O(E*V)
#空间复杂度：
#
#测试
mat = [[0,1,4,5],
      [1,0,1,0],
      [4,1,0,1],
      [5,0,1,0]]
G = GraghAL(mat)
#print(G)
#print(Krustal(G))
print(Prim(G))
print(Optimized_Prim(G))